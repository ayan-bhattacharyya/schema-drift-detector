/*
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Neo4j Seed: CSV Source - People-info -> Two raget files (Comapny and Personal Info)
// and snapshot _ lineage
// Rematch by key and no out of scope variables
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/


/* ----------------------------------------------------------
   Full idempotent Cypher 5 script (fixed scoping)
   - Entities: people-info.csv, company.csv, personal-info.csv
   - Fields for each entity
   - Snapshots + SampleRow nodes for source
   - ETLJob nodes
   - Transformation nodes + MAPPED_TO rels (each mapping block MATCHes required vars)
   - No APOC, Neo4j Community compatible
   ---------------------------------------------------------- */

/* -------------------- 0. Constraints -------------------- */
CREATE CONSTRAINT entity_name_unique IF NOT EXISTS FOR (e:Entity) REQUIRE e.name IS UNIQUE;
CREATE CONSTRAINT snapshot_id_unique IF NOT EXISTS FOR (s:Snapshot) REQUIRE s.id IS UNIQUE;
CREATE CONSTRAINT field_id_unique IF NOT EXISTS FOR (f:Field) REQUIRE f.field_id IS UNIQUE;
CREATE CONSTRAINT etljob_id_unique IF NOT EXISTS FOR (j:ETLJob) REQUIRE j.job_id IS UNIQUE;
CREATE CONSTRAINT transformation_id_unique IF NOT EXISTS FOR (t:Transformation) REQUIRE t.transformation_id IS UNIQUE;
CREATE CONSTRAINT samplerow_id_unique IF NOT EXISTS FOR (r:SampleRow) REQUIRE r.sample_id IS UNIQUE;

/* -------------------- 1. Upsert Entities -------------------- */
MERGE (srcEntity:Entity {name: 'people-info.csv'})
  ON CREATE SET srcEntity.type = 'file', srcEntity.source_path = 'people-info.csv', srcEntity.created = datetime()
  ON MATCH SET srcEntity.last_seen = datetime();

MERGE (companyEntity:Entity {name: 'company.csv'})
  ON CREATE SET companyEntity.type = 'file', companyEntity.source_path = 'company.csv', companyEntity.created = datetime()
  ON MATCH SET companyEntity.last_seen = datetime();

MERGE (personalEntity:Entity {name: 'personal-info.csv'})
  ON CREATE SET personalEntity.type = 'file', personalEntity.source_path = 'personal-info.csv', personalEntity.created = datetime()
  ON MATCH SET personalEntity.last_seen = datetime();

/* -------------------- 2. Snapshot + SampleRows (source) -------------------- */
MERGE (srcSnap:Snapshot {id: 'snapshot_peopleinfo_v1'})
  ON CREATE SET srcSnap.source = 'people-info.csv', srcSnap.timestamp = datetime(), srcSnap.version = 'v1', srcSnap.row_count = 2
  ON MATCH SET srcSnap.timestamp = datetime(), srcSnap.row_count = 2;

MATCH (srcSnap:Snapshot {id: 'snapshot_peopleinfo_v1'}), (srcEntity:Entity {name: 'people-info.csv'})
MERGE (srcSnap)-[:HAS_ENTITY]->(srcEntity);

/* Sample rows */
MERGE (r1:SampleRow {sample_id: 'snapshot_peopleinfo_v1_row_1'})
  ON CREATE SET r1.name = 'John Doe', r1.date_of_birth = '1985-06-15', r1.gender = 'M', r1.company = 'Acme', r1.designation = 'Engineer', r1.ordinal = 0
  ON MATCH SET r1.name = 'John Doe', r1.date_of_birth = '1985-06-15', r1.gender = 'M', r1.company = 'Acme', r1.designation = 'Engineer', r1.ordinal = 0;

MERGE (r2:SampleRow {sample_id: 'snapshot_peopleinfo_v1_row_2'})
  ON CREATE SET r2.name = 'Jane Smith', r2.date_of_birth = '1990-12-02', r2.gender = 'F', r2.company = 'Globex', r2.designation = 'Manager', r2.ordinal = 1
  ON MATCH SET r2.name = 'Jane Smith', r2.date_of_birth = '1990-12-02', r2.gender = 'F', r2.company = 'Globex', r2.designation = 'Manager', r2.ordinal = 1;

MATCH (srcSnap:Snapshot {id: 'snapshot_peopleinfo_v1'}), (r1:SampleRow {sample_id: 'snapshot_peopleinfo_v1_row_1'}), (r2:SampleRow {sample_id: 'snapshot_peopleinfo_v1_row_2'})
MERGE (srcSnap)-[:HAS_SAMPLE_ROW]->(r1)
MERGE (srcSnap)-[:HAS_SAMPLE_ROW]->(r2);

/* -------------------- 3. Fields for source -------------------- */
MATCH (srcEntity:Entity {name: 'people-info.csv'})
UNWIND [
  {name:'name', data_type:'string', nullable:false, ordinal:0, example:'John Doe'},
  {name:'date_of_birth', data_type:'date', nullable:false, ordinal:1, example:'1985-06-15'},
  {name:'gender', data_type:'string', nullable:true, ordinal:2, example:'M'},
  {name:'company', data_type:'string', nullable:true, ordinal:3, example:'Acme'},
  {name:'designation', data_type:'string', nullable:true, ordinal:4, example:'Engineer'}
] AS f
WITH srcEntity, f, (CASE WHEN f.nullable THEN 'true' ELSE 'false' END) AS nullable_str
MERGE (sf:Field {field_id: srcEntity.name + '|' + f.name + '|' + f.data_type + '|' + nullable_str})
  ON CREATE SET sf.name = f.name, sf.data_type = f.data_type, sf.nullable = f.nullable, sf.ordinal = f.ordinal, sf.example = f.example
  ON MATCH SET sf.example = f.example, sf.ordinal = f.ordinal
MERGE (srcEntity)-[:HAS_FIELD]->(sf);

/* -------------------- 4. Fields for company target -------------------- */
MATCH (companyEntity:Entity {name: 'company.csv'})
UNWIND [
  {name:'first_name', data_type:'string', nullable:false, ordinal:0, example:'John'},
  {name:'surname', data_type:'string', nullable:false, ordinal:1, example:'Doe'},
  {name:'company', data_type:'string', nullable:true, ordinal:2, example:'Acme'},
  {name:'designation', data_type:'string', nullable:true, ordinal:3, example:'Engineer'}
] AS f
WITH companyEntity, f, (CASE WHEN f.nullable THEN 'true' ELSE 'false' END) AS nullable_str
MERGE (cf:Field {field_id: companyEntity.name + '|' + f.name + '|' + f.data_type + '|' + nullable_str})
  ON CREATE SET cf.name = f.name, cf.data_type = f.data_type, cf.nullable = f.nullable, cf.ordinal = f.ordinal, cf.example = f.example
  ON MATCH SET cf.example = f.example, cf.ordinal = f.ordinal
MERGE (companyEntity)-[:HAS_FIELD]->(cf);

/* -------------------- 5. Fields for personal target -------------------- */
MATCH (personalEntity:Entity {name: 'personal-info.csv'})
UNWIND [
  {name:'first_name', data_type:'string', nullable:false, ordinal:0, example:'John'},
  {name:'surname', data_type:'string', nullable:false, ordinal:1, example:'Doe'},
  {name:'date_of_birth', data_type:'date', nullable:false, ordinal:2, example:'1985-06-15'},
  {name:'age', data_type:'int', nullable:true, ordinal:3, example:'40'},
  {name:'gender', data_type:'string', nullable:true, ordinal:4, example:'M'}
] AS f
WITH personalEntity, f, (CASE WHEN f.nullable THEN 'true' ELSE 'false' END) AS nullable_str
MERGE (pf:Field {field_id: personalEntity.name + '|' + f.name + '|' + f.data_type + '|' + nullable_str})
  ON CREATE SET pf.name = f.name, pf.data_type = f.data_type, pf.nullable = f.nullable, pf.ordinal = f.ordinal, pf.example = f.example
  ON MATCH SET pf.example = f.example, pf.ordinal = f.ordinal
MERGE (personalEntity)-[:HAS_FIELD]->(pf);

/* -------------------- 6. Upsert ETL jobs and link to entities -------------------- */
MATCH (src:Entity {name:'people-info.csv'}), (comp:Entity {name:'company.csv'}), (pers:Entity {name:'personal-info.csv'})
MERGE (jobCompany:ETLJob {job_id: 'job_company_v1'})
  ON CREATE SET jobCompany.name = 'company_job', jobCompany.description = 'ETL job: people-info.csv -> company.csv', jobCompany.created = datetime(), jobCompany.schedule = 'ad-hoc'
  ON MATCH SET jobCompany.last_seen = datetime()
MERGE (jobPersonal:ETLJob {job_id: 'job_personalinfo_v1'})
  ON CREATE SET jobPersonal.name = 'personal_info_job', jobPersonal.description = 'ETL job: people-info.csv -> personal-info.csv', jobPersonal.created = datetime(), jobPersonal.schedule = 'ad-hoc'
  ON MATCH SET jobPersonal.last_seen = datetime()
MERGE (jobCompany)-[:USES_SOURCE]->(src)
MERGE (jobCompany)-[:PRODUCES]->(comp)
MERGE (jobPersonal)-[:USES_SOURCE]->(src)
MERGE (jobPersonal)-[:PRODUCES]->(pers);

/* -------------------- 7. Company job mapping: first_name (mapping_order=0) -------------------- */
MATCH
  (s:Entity {name:'people-info.csv'})-[:HAS_FIELD]->(sf_name:Field {name:'name'}),
  (t:Entity {name:'company.csv'})-[:HAS_FIELD]->(tf_first:Field {name:'first_name'}),
  (job:ETLJob {job_id:'job_company_v1'})
MERGE (trans0:Transformation {transformation_id: job.job_id + '|' + '0'})
  ON CREATE SET trans0.job_id = job.job_id, trans0.mapping_order = 0, trans0.source_field = sf_name.field_id, trans0.target_field = tf_first.field_id,
                trans0.expression = "split(name, ' ')[0]", trans0.description = "first_name = first token of source.name", trans0.created = datetime()
  ON MATCH SET trans0.source_field = sf_name.field_id, trans0.target_field = tf_first.field_id, trans0.expression = "split(name, ' ')[0]"
MERGE (sf_name)-[m0:MAPPED_TO {job_id: job.job_id, mapping_order: 0}]->(tf_first) ON CREATE SET m0.expression = "split(name, ' ')[0]" ON MATCH SET m0.expression = "split(name, ' ')[0]"
MERGE (trans0)-[:APPLIES_TO_JOB]->(job)
MERGE (trans0)-[:MAPS_SOURCE]->(sf_name)
MERGE (trans0)-[:MAPS_TARGET]->(tf_first);

/* -------------------- 8. Company job mapping: surname (mapping_order=1) -------------------- */
MATCH
  (s:Entity {name:'people-info.csv'})-[:HAS_FIELD]->(sf_name2:Field {name:'name'}),
  (t:Entity {name:'company.csv'})-[:HAS_FIELD]->(tf_surname:Field {name:'surname'}),
  (job:ETLJob {job_id:'job_company_v1'})
MERGE (trans1:Transformation {transformation_id: job.job_id + '|' + '1'})
  ON CREATE SET trans1.job_id = job.job_id, trans1.mapping_order = 1, trans1.source_field = sf_name2.field_id, trans1.target_field = tf_surname.field_id,
                trans1.expression = "split(name, ' ')[size(split(name,' '))-1]", trans1.description = "surname = last token of source.name", trans1.created = datetime()
  ON MATCH SET trans1.source_field = sf_name2.field_id, trans1.target_field = tf_surname.field_id, trans1.expression = "split(name, ' ')[size(split(name,' '))-1]"
MERGE (sf_name2)-[m1:MAPPED_TO {job_id: job.job_id, mapping_order: 1}]->(tf_surname) ON CREATE SET m1.expression = "split(name, ' ')[size(split(name,' '))-1]" ON MATCH SET m1.expression = "split(name, ' ')[size(split(name,' '))-1]"
MERGE (trans1)-[:APPLIES_TO_JOB]->(job)
MERGE (trans1)-[:MAPS_SOURCE]->(sf_name2)
MERGE (trans1)-[:MAPS_TARGET]->(tf_surname);

/* -------------------- 9. Company job mapping: company (mapping_order=2) -------------------- */
MATCH
  (s:Entity {name:'people-info.csv'})-[:HAS_FIELD]->(sf_company:Field {name:'company'}),
  (t:Entity {name:'company.csv'})-[:HAS_FIELD]->(tf_company:Field {name:'company'}),
  (job:ETLJob {job_id:'job_company_v1'})
MERGE (trans2:Transformation {transformation_id: job.job_id + '|' + '2'})
  ON CREATE SET trans2.job_id = job.job_id, trans2.mapping_order = 2, trans2.source_field = sf_company.field_id, trans2.target_field = tf_company.field_id,
                trans2.expression = "company -> company", trans2.description = "company copied from source.company", trans2.created = datetime()
  ON MATCH SET trans2.source_field = sf_company.field_id, trans2.target_field = tf_company.field_id, trans2.expression = "company -> company"
MERGE (sf_company)-[m2:MAPPED_TO {job_id: job.job_id, mapping_order: 2}]->(tf_company) ON CREATE SET m2.expression = "company -> company" ON MATCH SET m2.expression = "company -> company"
MERGE (trans2)-[:APPLIES_TO_JOB]->(job)
MERGE (trans2)-[:MAPS_SOURCE]->(sf_company)
MERGE (trans2)-[:MAPS_TARGET]->(tf_company);

/* -------------------- 10. Company job mapping: designation (mapping_order=3) -------------------- */
MATCH
  (s:Entity {name:'people-info.csv'})-[:HAS_FIELD]->(sf_designation:Field {name:'designation'}),
  (t:Entity {name:'company.csv'})-[:HAS_FIELD]->(tf_designation:Field {name:'designation'}),
  (job:ETLJob {job_id:'job_company_v1'})
MERGE (trans3:Transformation {transformation_id: job.job_id + '|' + '3'})
  ON CREATE SET trans3.job_id = job.job_id, trans3.mapping_order = 3, trans3.source_field = sf_designation.field_id, trans3.target_field = tf_designation.field_id,
                trans3.expression = "designation -> designation", trans3.description = "designation copied from source.designation", trans3.created = datetime()
  ON MATCH SET trans3.source_field = sf_designation.field_id, trans3.target_field = tf_designation.field_id, trans3.expression = "designation -> designation"
MERGE (sf_designation)-[m3:MAPPED_TO {job_id: job.job_id, mapping_order: 3}]->(tf_designation) ON CREATE SET m3.expression = "designation -> designation" ON MATCH SET m3.expression = "designation -> designation"
MERGE (trans3)-[:APPLIES_TO_JOB]->(job)
MERGE (trans3)-[:MAPS_SOURCE]->(sf_designation)
MERGE (trans3)-[:MAPS_TARGET]->(tf_designation);

/* -------------------- 11. Personal job mapping: first_name (0) -------------------- */
MATCH
  (s2:Entity {name:'people-info.csv'})-[:HAS_FIELD]->(sf_name_p:Field {name:'name'}),
  (p:Entity {name:'personal-info.csv'})-[:HAS_FIELD]->(pf_first:Field {name:'first_name'}),
  (jobp:ETLJob {job_id:'job_personalinfo_v1'})
MERGE (t_p_0:Transformation {transformation_id: jobp.job_id + '|' + '0'})
  ON CREATE SET t_p_0.job_id = jobp.job_id, t_p_0.mapping_order = 0, t_p_0.source_field = sf_name_p.field_id, t_p_0.target_field = pf_first.field_id,
                t_p_0.expression = "split(name, ' ')[0]", t_p_0.description = "first_name = first token of source.name", t_p_0.created = datetime()
  ON MATCH SET t_p_0.source_field = sf_name_p.field_id, t_p_0.target_field = pf_first.field_id, t_p_0.expression = "split(name, ' ')[0]"
MERGE (sf_name_p)-[pm0:MAPPED_TO {job_id: jobp.job_id, mapping_order: 0}]->(pf_first) ON CREATE SET pm0.expression = "split(name, ' ')[0]" ON MATCH SET pm0.expression = "split(name, ' ')[0]"
MERGE (t_p_0)-[:APPLIES_TO_JOB]->(jobp)
MERGE (t_p_0)-[:MAPS_SOURCE]->(sf_name_p)
MERGE (t_p_0)-[:MAPS_TARGET]->(pf_first);

/* -------------------- 12. Personal job mapping: surname (1) -------------------- */
MATCH
  (s2:Entity {name:'people-info.csv'})-[:HAS_FIELD]->(sf_name_p2:Field {name:'name'}),
  (p:Entity {name:'personal-info.csv'})-[:HAS_FIELD]->(pf_surname:Field {name:'surname'}),
  (jobp:ETLJob {job_id:'job_personalinfo_v1'})
MERGE (t_p_1:Transformation {transformation_id: jobp.job_id + '|' + '1'})
  ON CREATE SET t_p_1.job_id = jobp.job_id, t_p_1.mapping_order = 1, t_p_1.source_field = sf_name_p2.field_id, t_p_1.target_field = pf_surname.field_id,
                t_p_1.expression = "split(name, ' ')[size(split(name,' '))-1]", t_p_1.description = "surname = last token of source.name", t_p_1.created = datetime()
  ON MATCH SET t_p_1.source_field = sf_name_p2.field_id, t_p_1.target_field = pf_surname.field_id, t_p_1.expression = "split(name, ' ')[size(split(name,' '))-1]"
MERGE (sf_name_p2)-[pm1:MAPPED_TO {job_id: jobp.job_id, mapping_order: 1}]->(pf_surname) ON CREATE SET pm1.expression = "split(name, ' ')[size(split(name,' '))-1]" ON MATCH SET pm1.expression = "split(name, ' ')[size(split(name,' '))-1]"
MERGE (t_p_1)-[:APPLIES_TO_JOB]->(jobp)
MERGE (t_p_1)-[:MAPS_SOURCE]->(sf_name_p2)
MERGE (t_p_1)-[:MAPS_TARGET]->(pf_surname);

/* -------------------- 13. Personal job mapping: date_of_birth (2) -------------------- */
MATCH
  (s2:Entity {name:'people-info.csv'})-[:HAS_FIELD]->(sf_dob:Field {name:'date_of_birth'}),
  (p:Entity {name:'personal-info.csv'})-[:HAS_FIELD]->(pf_dob:Field {name:'date_of_birth'}),
  (jobp:ETLJob {job_id:'job_personalinfo_v1'})
MERGE (t_p_2:Transformation {transformation_id: jobp.job_id + '|' + '2'})
  ON CREATE SET t_p_2.job_id = jobp.job_id, t_p_2.mapping_order = 2, t_p_2.source_field = sf_dob.field_id, t_p_2.target_field = pf_dob.field_id,
                t_p_2.expression = "date_of_birth -> date_of_birth", t_p_2.description = "date_of_birth parsed as date", t_p_2.created = datetime()
  ON MATCH SET t_p_2.source_field = sf_dob.field_id, t_p_2.target_field = pf_dob.field_id, t_p_2.expression = "date_of_birth -> date_of_birth"
MERGE (sf_dob)-[pm2:MAPPED_TO {job_id: jobp.job_id, mapping_order: 2}]->(pf_dob) ON CREATE SET pm2.expression = "date_of_birth -> date_of_birth" ON MATCH SET pm2.expression = "date_of_birth -> date_of_birth"
MERGE (t_p_2)-[:APPLIES_TO_JOB]->(jobp)
MERGE (t_p_2)-[:MAPS_SOURCE]->(sf_dob)
MERGE (t_p_2)-[:MAPS_TARGET]->(pf_dob);

/* -------------------- 14. Personal job mapping: age (3) -------------------- */
MATCH
  (s2:Entity {name:'people-info.csv'})-[:HAS_FIELD]->(sf_dob2:Field {name:'date_of_birth'}),
  (p:Entity {name:'personal-info.csv'})-[:HAS_FIELD]->(pf_age:Field {name:'age'}),
  (jobp:ETLJob {job_id:'job_personalinfo_v1'})
MERGE (t_p_3:Transformation {transformation_id: jobp.job_id + '|' + '3'})
  ON CREATE SET t_p_3.job_id = jobp.job_id, t_p_3.mapping_order = 3, t_p_3.source_field = sf_dob2.field_id, t_p_3.target_field = pf_age.field_id,
                t_p_3.expression = "age = floor(duration.between(date_parsed(date_of_birth), date()).years)", t_p_3.description = "age computed from date_of_birth", t_p_3.created = datetime()
  ON MATCH SET t_p_3.source_field = sf_dob2.field_id, t_p_3.target_field = pf_age.field_id, t_p_3.expression = "age = floor(duration.between(date_parsed(date_of_birth), date()).years)"
MERGE (sf_dob2)-[pm3:MAPPED_TO {job_id: jobp.job_id, mapping_order: 3}]->(pf_age) ON CREATE SET pm3.expression = "age = floor(duration.between(date_parsed(date_of_birth), date()).years)" ON MATCH SET pm3.expression = "age = floor(duration.between(date_parsed(date_of_birth), date()).years)"
MERGE (t_p_3)-[:APPLIES_TO_JOB]->(jobp)
MERGE (t_p_3)-[:MAPS_SOURCE]->(sf_dob2)
MERGE (t_p_3)-[:MAPS_TARGET]->(pf_age);

/* -------------------- 15. Personal job mapping: gender (4) -------------------- */
MATCH
  (s2:Entity {name:'people-info.csv'})-[:HAS_FIELD]->(sf_gender:Field {name:'gender'}),
  (p:Entity {name:'personal-info.csv'})-[:HAS_FIELD]->(pf_gender:Field {name:'gender'}),
  (jobp:ETLJob {job_id:'job_personalinfo_v1'})
MERGE (t_p_4:Transformation {transformation_id: jobp.job_id + '|' + '4'})
  ON CREATE SET t_p_4.job_id = jobp.job_id, t_p_4.mapping_order = 4, t_p_4.source_field = sf_gender.field_id, t_p_4.target_field = pf_gender.field_id,
                t_p_4.expression = "gender -> gender", t_p_4.description = "gender copied from source.gender", t_p_4.created = datetime()
  ON MATCH SET t_p_4.source_field = sf_gender.field_id, t_p_4.target_field = pf_gender.field_id, t_p_4.expression = "gender -> gender"
MERGE (sf_gender)-[pm4:MAPPED_TO {job_id: jobp.job_id, mapping_order: 4}]->(pf_gender) ON CREATE SET pm4.expression = "gender -> gender" ON MATCH SET pm4.expression = "gender -> gender"
MERGE (t_p_4)-[:APPLIES_TO_JOB]->(jobp)
MERGE (t_p_4)-[:MAPS_SOURCE]->(sf_gender)
MERGE (t_p_4)-[:MAPS_TARGET]->(pf_gender);

/* -------------------- 16. Convenience relationships: Entity <-> Job -------------------- */
MATCH (je:ETLJob {job_id:'job_company_v1'}), (e:Entity {name:'people-info.csv'}), (t:Entity {name:'company.csv'})
MERGE (e)-[:SOURCE_FOR {job_id: je.job_id}]->(je)
MERGE (je)-[:TARGETS]->(t);

MATCH (je2:ETLJob {job_id:'job_personalinfo_v1'}), (e2:Entity {name:'people-info.csv'}), (t2:Entity {name:'personal-info.csv'})
MERGE (e2)-[:SOURCE_FOR {job_id: je2.job_id}]->(je2)
MERGE (je2)-[:TARGETS]->(t2);

/* -------------------- 17. Return verification counts -------------------- */
CALL { MATCH (n:Snapshot) RETURN count(n) AS snapshot_count }
CALL { MATCH (m:Entity) RETURN count(m) AS entity_count }
CALL { MATCH (f:Field) RETURN count(f) AS field_count }
CALL { MATCH (r:SampleRow) RETURN count(r) AS samplerow_count }
CALL { MATCH (j:ETLJob) RETURN count(j) AS etljob_count }
CALL { MATCH (t:Transformation) RETURN count(t) AS transformation_count }
RETURN snapshot_count, entity_count, field_count, samplerow_count, etljob_count, transformation_count;

/* 6. Upsert field-level mappings for personal_info_job */
MATCH
  (s2:Entity {name:'people-info.csv'})-[:HAS_FIELD]->(sf_name2:Field {name:'name'}),
  (s2)-[:HAS_FIELD]->(sf_dob:Field {name:'date_of_birth'}),
  (s2)-[:HAS_FIELD]->(sf_gender:Field {name:'gender'}),
  (p:Entity {name:'personal-info.csv'})-[:HAS_FIELD]->(pf_first:Field {name:'first_name'}),
  (p)-[:HAS_FIELD]->(pf_surname:Field {name:'surname'}),
  (p)-[:HAS_FIELD]->(pf_dob:Field {name:'date_of_birth'}),
  (p)-[:HAS_FIELD]->(pf_age:Field {name:'age'}),
  (p)-[:HAS_FIELD]->(pf_gender:Field {name:'gender'}),
  (jobp:ETLJob {job_id:'job_personalinfo_v1'})
MERGE (sf_name2)-[pm1:MAPPED_TO {job_id: jobp.job_id, mapping_order: 0}]->(pf_first)
  ON CREATE SET pm1.expression = "split(name, ' ')[0]", pm1.transform_desc = "first_name = first token of source.name"
  ON MATCH SET pm1.expression = "split(name, ' ')[0]", pm1.transform_desc = "first_name = first token of source.name"
MERGE (sf_name2)-[pm2:MAPPED_TO {job_id: jobp.job_id, mapping_order: 1}]->(pf_surname)
  ON CREATE SET pm2.expression = "split(name, ' ')[size(split(name,' '))-1]", pm2.transform_desc = "surname = last token of source.name"
  ON MATCH SET pm2.expression = "split(name, ' ')[size(split(name,' '))-1]", pm2.transform_desc = "surname = last token of source.name"
MERGE (sf_dob)-[pm3:MAPPED_TO {job_id: jobp.job_id, mapping_order: 2}]->(pf_dob)
  ON CREATE SET pm3.expression = "date_of_birth -> date_of_birth (direct copy, parse to date)", pm3.transform_desc = "date_of_birth parsed as date"
  ON MATCH SET pm3.expression = "date_of_birth -> date_of_birth (direct copy, parse to date)", pm3.transform_desc = "date_of_birth parsed as date"
MERGE (sf_dob)-[pm4:MAPPED_TO {job_id: jobp.job_id, mapping_order: 3}]->(pf_age)
  ON CREATE SET pm4.expression = "age = floor(duration.between(date_parsed(date_of_birth), date()).years)", pm4.transform_desc = "age computed from date_of_birth"
  ON MATCH SET pm4.expression = "age = floor(duration.between(date_parsed(date_of_birth), date()).years)", pm4.transform_desc = "age computed from date_of_birth"
MERGE (sf_gender)-[pm5:MAPPED_TO {job_id: jobp.job_id, mapping_order: 4}]->(pf_gender)
  ON CREATE SET pm5.expression = "gender -> gender (direct copy)", pm5.transform_desc = "gender copied from source.gender"
  ON MATCH SET pm5.expression = "gender -> gender (direct copy)", pm5.transform_desc = "gender copied from source.gender";

/* Ensure convenience jobp->FIELD_MAPPINGS relationships (no duplicates) */
MATCH (jobp:ETLJob {job_id:'job_personalinfo_v1'}), (pf_first:Field {field_id: 'personal-info.csv|first_name|string|false'})
MERGE (jobp)-[:FIELD_MAPPINGS]->(pf_first);
MATCH (jobp:ETLJob {job_id:'job_personalinfo_v1'}), (pf_surname:Field {field_id: 'personal-info.csv|surname|string|false'})
MERGE (jobp)-[:FIELD_MAPPINGS]->(pf_surname);
MATCH (jobp:ETLJob {job_id:'job_personalinfo_v1'}), (pf_dob:Field {field_id: 'personal-info.csv|date_of_birth|date|false'})
MERGE (jobp)-[:FIELD_MAPPINGS]->(pf_dob);
MATCH (jobp:ETLJob {job_id:'job_personalinfo_v1'}), (pf_age:Field {field_id: 'personal-info.csv|age|int|true'})
MERGE (jobp)-[:FIELD_MAPPINGS]->(pf_age);
MATCH (jobp:ETLJob {job_id:'job_personalinfo_v1'}), (pf_gender:Field {field_id: 'personal-info.csv|gender|string|true'})
MERGE (jobp)-[:FIELD_MAPPINGS]->(pf_gender);

/* 7. Entity <-> Job convenience relationships */
MATCH (je:ETLJob {job_id:'job_company_v1'}), (e:Entity {name:'people-info.csv'}), (t:Entity {name:'company.csv'})
MERGE (e)-[:SOURCE_FOR {job_id: je.job_id}]->(je)
MERGE (je)-[:TARGETS]->(t);

MATCH (je2:ETLJob {job_id:'job_personalinfo_v1'}), (e2:Entity {name:'people-info.csv'}), (t2:Entity {name:'personal-info.csv'})
MERGE (e2)-[:SOURCE_FOR {job_id: je2.job_id}]->(je2)
MERGE (je2)-[:TARGETS]->(t2);

/* 8. Return verification counts */
CALL {
  MATCH (n:Snapshot) RETURN count(n) AS snapshot_count
}
CALL {
  MATCH (m:Entity) RETURN count(m) AS entity_count
}
CALL {
  MATCH (f:Field) RETURN count(f) AS field_count
}
CALL {
  MATCH (r:SampleRow) RETURN count(r) AS samplerow_count
}
CALL {
  MATCH (j:ETLJob) RETURN count(j) AS etljob_count
}
RETURN snapshot_count, entity_count, field_count, samplerow_count, etljob_count;
